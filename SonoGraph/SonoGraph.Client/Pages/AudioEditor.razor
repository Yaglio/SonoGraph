@page "/editor"
@rendermode InteractiveWebAssembly

@inject AudioPlayerService audioPlayerService
@inject StorageService storageService

@using SonoGraph.Client.Models

<!--AudioEditor UI. Has functions to display and delete many audios at once and to control the playback of audios.
Merge and other tools require external methods (Anna), input comes from external source via addAudio(Audio).
For removing an audio use removeAudio(Audio).

Author: DaveH
-->

<!--global header-->
<header class="gHeader">
	<h3 class="pageTitle">Audio Editor</h3>
	<span class="gVolDisplay"> Global volume: @audioPlayerService.MasterVolume%</span>
	<input class="globalVol" type="range" min="0" max="100" @bind="@audioPlayerService.MasterVolume" @bind:event="oninput" />
</header>

<CascadingValue Value="storageService">
	<div class="editorcontainer">
		<div class="contentcontainer">
			<h3>Audio tracks</h3>
			@foreach (var Audio in Audios)
			{
				<div class="audioItem">
					<span class="audioIndex">@(Audios.IndexOf(Audio) + 1)</span>

					<button type="button"
					class="bar"
					style="width: @(getWidth(Audio))px;
                           background-color: @audioColors[Audio];
                           border: @(selected.Contains(Audio) ? "3px solid #FF6347" : "2px solid black");"
					@onclick="@(() => SelectBar(Audio))">
						@(Audio.GetHashCode())
					</button>
				</div>
			}

			<!-- Scale -->
			<div class="scale" style="width:@(getMaxWidth())px;">
				@{
					double max = getMaxWidth();
					if (max > 0)
					{
						@for (int i = 0; i < max; i += 50)
						{
							<span class="scaleMark" style="left:@(i)px;"></span>
							@if (i % 100 == 0)
							{
								double sec = i / 1000.0;
								<span class="scaleLabel" style="left:@(i)px;">@sec</span>
							}
						}
					}
				}
			</div>
		</div>
		<div class="toolcontainer">
			<h3>Tools</h3>
			<p>@getHash()</p>
			<div class="toolCat">
				<p class="toolCatName">Audio modification</p>
				<button class="toolD" @onclick="DeleteSelected">Delete selected</button>
				<button class="toolD" @onclick="DeleteAll">Delete all</button>
				<button class="tool" @onclick="addAudio">Add test audio</button>
				<button class="tool" @onclick="merge">Merge tracks</button>
			</div>
			<div class="toolCat">
				<p class="toolCatName">Playback control</p>
				<button class="tool" @onclick="play">Play</button>
				<button class="tool" @onclick="stop">Stop</button>
			</div>
		</div>
	</div>
</CascadingValue>

@code {
	List<Audio> Audios = StorageService.Audios;
	String[] colors =
	{
		"#FF9F80", // Light Red-Orange
        "#80FF9F", // Light Green
        "#809FFF", // Light Blue
        "#F1E0A3", // Light Yellow
        "#D7A1D4", // Soft Purple
        "#F1A15F", // Soft Orange
        "#70D1D1", // Light Turquoise
        "#A1E1A1", // Soft Emerald Green
        "#F1C676", // Soft Golden Yellow
        "#B58BCA"  // Light Dark Purple
	};

	protected string getHash()
	{
		return selected.Count > 0 ? $"selected {selected.Count} track(s)" : "no tracks selected";
	}

	protected double getWidth(Audio audio)
	{
		return AudioUtils.GetDuration(audio);
	}

	protected double getMaxWidth()
	{
		if (Audios.Any())
		{
			return Audios.Max(audio => getWidth(audio));
		}
		return 0;
	}

	protected override void OnInitialized()
	{
		base.OnInitialized();
	}

	Dictionary<Audio, string> audioColors = StorageService.audioColors;

	protected void addAudio() // add test audio
	{
		addAudio(AudioUtils.CreateTestAudio());
	}

	public void addAudio(Audio audio) // add some audio
	{
		Audios.Add(audio);

		string color = colors[Audios.Count % colors.Length];
		audioColors[audio] = color;
	}

	public void removeAudio(Audio audio) // remove specific audio
	{
		Audios.Remove(audio);
	}

	List<Audio> selected = StorageService.selected;

	void SelectBar(Audio audio)
	{
		if (selected.Contains(audio))
		{
			selected.Remove(audio);
		}
		else
		{
			selected.Add(audio);
		}
	}

	void DeleteSelected()
	{
		foreach (var audio in selected)
		{
			Audios.Remove(audio);
		}
		selected.Clear();
	}

	void DeleteAll()
	{
		Audios.Clear();
		selected.Clear();
	}

	void merge()
	{
		if (selected.Count > 1)
		{
			// TODO call external merge method
			DeleteSelected();
		}
	}

	private Dictionary<Audio, CancellationTokenSource> playbackTokens = new();

	private async Task play()
	{
		await stop();
		await audioPlayerService.Initialize();

		foreach (var audio in selected)
		{
			var cts = new CancellationTokenSource();
			playbackTokens[audio] = cts;

			_ = PlayAudioAsync(audio, cts.Token);
		}
	}

	private async Task PlayAudioAsync(Audio audio, CancellationToken token)
	{
		try
		{
			await audioPlayerService.Play(audio, token);
		}
		catch (OperationCanceledException)
		{
			Console.WriteLine($"Playback of {audio.GetHashCode()} cancelled.");
		}
	}

	private async Task stop()
	{
		foreach (var kv in playbackTokens)
		{
			kv.Value.Cancel();
		}

		await Task.Delay(100);

		playbackTokens.Clear();
	}
}
