@page "/editor"
@rendermode InteractiveWebAssembly

@inject AudioPlayerService audioPlayerService
@inject StorageService storageService

@using SonoGraph.Client.Models

<!--AudioEditor UI. Has functions to display and delete many audios at once and to control the playback of audios.
Merge and other tools require external methods (Anna), input comes from external source via addAudio(Audio).
For removing an audio use removeAudio(Audio).

Author: DaveH
-->
<!--global header-->
<header class="gHeader">
	<h3 class="pageTitle">Audio Editor</h3>
	<span class="gVolDisplay"> Global volume: @audioPlayerService.MasterVolume%</span>
	<input class="globalVol" type="range" min="0" max="100" @bind="@audioPlayerService.MasterVolume" @bind:event="oninput" />
</header>

<CascadingValue Value="storageService">
	<div class="editorcontainer">
		<div class="contentcontainer">
			<h3>Audio tracks</h3>
			@foreach (var audio in Audios)
			{
				<div class="audioItem">
					<button class="audioIndex"
					style="border: @(SelectedAudios.Contains(audio) ? "3px solid #FF6347" : "2px solid black");"
					@onclick="@(() => SelectBar(audio))">
						@(Audios.IndexOf(audio) + 1)
					</button>

					@foreach (var sound in audio.Sounds)
					{
						<button type="button"
						class="bar"
								style="width: @(sound.Duration * scaleWidth)px;
								height: @(getHeight(sound.Frequency))px;
								background-color: @audioColors[audio];
								border: @(SelectedSounds.Contains(sound) || SelectedAudios.Contains(audio) ? "2px solid #FF6347" : "2px solid black");"
						@onclick="@(() => SelectBar(sound))">
						</button>
					}

				</div>
			}

			<!-- Scale -->
			<div class="scale" style="width:@(getMaxWidth() * scaleWidth)px;">
				@{
					double maxTime = getMaxWidth(); // in ms
					double pixelPerMs = scaleWidth;

					if (maxTime > 0)
					{
						for (int time = 0; time < maxTime; time += 250)
						{
							double left = time * pixelPerMs;
							<span class="scaleMark" style="left:@(left)px;"></span>

							if (time % 500 == 0)
							{
								double sec = time / 1000.0;
								<span class="scaleLabel" style="left:@(left)px;">@sec</span>
							}
						}
					}
				}
			</div>
		</div>
		<div class="toolcontainer">
			<h3>Tools</h3>
			<p class="counter">@getCount()</p>
			<div class="toolCat">
				<p class="toolCatName">Audio modification</p>
				<button class="toolD" @onclick="DeleteSelected">Delete selected</button>
				<button class="toolD" @onclick="DeleteAllAudios">Delete all audios</button>
				<button class="tool" @onclick="addAudio">Add test audio</button>
				<button class="tool" @onclick="merge">Merge tracks</button>
			</div>
			<div class="toolCat">
				<p class="toolCatName">Playback control</p>
				<button class="tool" @onclick="play">Play</button>
				<button class="tool" @onclick="stop">Stop</button>
			</div>
		</div>
	</div>
</CascadingValue>

@code {
	private double scaleWidth = 0.2;
	List<Audio> Audios = StorageService.Audios;
	List<Audio> SelectedAudios = StorageService.SelectedAudios;
	List<Sound> SelectedSounds = StorageService.SelectedSounds;
	String[] colors =
	{
		"#FF9F80", // Light Red-Orange
        "#80FF9F", // Light Green
        "#809FFF", // Light Blue
        "#F1E0A3", // Light Yellow
        "#D7A1D4", // Soft Purple
        "#F1A15F", // Soft Orange
        "#70D1D1", // Light Turquoise
        "#A1E1A1", // Soft Emerald Green
        "#F1C676", // Soft Golden Yellow
        "#B58BCA"  // Light Dark Purple
	};

	protected int getHeight(double frequency)
	{
		if (frequency < 0) frequency = 0;

		if (frequency <= 100)
		{
			// 0 - 100hz → 25px
			return (int)((frequency / 100.0) * 25);
		}
		else if (frequency <= 1000)
		{
			// 100 - 1000hz → 100px
			return 25 + (int)(((frequency - 100) / 900.0) * 100);
		}
		else
		{
			// 1000 - 20000hz → 75px
			return 125 + (int)(((frequency - 1000) / 19000.0) * 75);
		}
	}


	protected string getCount()
	{
		StringWriter sw = new StringWriter();
		sw.WriteLine(SelectedAudios.Count > 0 ? $"selected {SelectedAudios.Count} audio(s)" : "no tracks selected");
		sw.WriteLine(SelectedSounds.Count > 0 ? $"selected {SelectedSounds.Count} sound(s)" : "no sounds selected");
		return sw.ToString();
	}

	protected double getWidth(Audio audio)
	{
		return AudioUtils.GetDuration(audio);
	}

	protected double getMaxWidth()
	{
		if (Audios.Any())
		{
			return Audios.Max(audio => getWidth(audio));
		}
		return 0;
	}

	protected override void OnInitialized()
	{
		base.OnInitialized();
	}

	Dictionary<Audio, string> audioColors = StorageService.audioColors;

	protected void addAudio() // add test audio
	{
		addAudio(AudioUtils.CreateTestAudio());
	}

	public void addAudio(Audio audio) // add some specific audio
	{
		Audios.Add(audio);

		foreach (var sound in audio.Sounds)
		{
			soundToAudioMap[sound] = audio;
		}

		string color = colors[Audios.Count % colors.Length];
		audioColors[audio] = color;
	}

	public void removeAudio(Audio audio) // remove some specific audio
	{
		foreach (var sound in audio.Sounds)
		{
			soundToAudioMap.Remove(sound);
		}

		Audios.Remove(audio);
	}

	public Audio? getParent(Sound sound) // get audio of some specific sound
	{
		if (soundToAudioMap.TryGetValue(sound, out var audio))
		{
			return audio;
		}
		return null;
	}

	public List<Audio> getSelectedAudios()
	{
		return SelectedAudios;
	}

	public List<Sound> getSelectedSounds()
	{
		return SelectedSounds;
	}

	void SelectBar(Audio audio)
	{
		if (SelectedAudios.Contains(audio))
		{
			SelectedAudios.Remove(audio);
		}
		else
		{
			SelectedAudios.Add(audio);
		}
	}

	private Dictionary<Sound, Audio> soundToAudioMap = new();

	void SelectBar(Sound sound)
	{
		if (soundToAudioMap.TryGetValue(sound, out var parentAudio))
		{
			SelectedAudios.Remove(parentAudio);
		}

		if (SelectedSounds.Contains(sound))
		{
			SelectedSounds.Remove(sound);
		}
		else
		{
			SelectedSounds.Add(sound);
		}
	}


	void DeleteSelected()
	{
		foreach (var audio in SelectedAudios)
		{
			removeAudio(audio);
		}

		SelectedAudios.Clear();
		SelectedSounds.Clear();
	}

	void DeleteAllAudios()
	{
		Audios.Clear();
		SelectedAudios.Clear();
		SelectedSounds.Clear();
		soundToAudioMap.Clear();
	}

	void merge()
	{
		if (SelectedAudios.Count > 1)
		{
			// TODO call external merge method
			DeleteSelected();
		}
	}

	private Dictionary<Audio, CancellationTokenSource> playbackTokens = new();

	private async Task play()
	{
		await stop();
		await audioPlayerService.Initialize();

		foreach (var audio in SelectedAudios)
		{
			var cts = new CancellationTokenSource();
			playbackTokens[audio] = cts;

			_ = PlayAudioAsync(audio, cts.Token);
		}
	}

	private async Task PlayAudioAsync(Audio audio, CancellationToken token)
	{
		try
		{
			await audioPlayerService.Play(audio, token);
		}
		catch (OperationCanceledException)
		{
			Console.WriteLine($"Playback of {audio.GetHashCode()} cancelled.");
		}
	}

	private async Task stop()
	{
		foreach (var kv in playbackTokens)
		{
			kv.Value.Cancel();
		}

		await Task.Delay(100);

		playbackTokens.Clear();
	}
}
